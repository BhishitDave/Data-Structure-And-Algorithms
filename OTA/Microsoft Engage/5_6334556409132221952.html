
<script type="text/x-mathjax-config">MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  jax: ["input/TeX","input/MathML","output/HTML-CSS","output/NativeMML"],
  extensions: ["tex2jax.js","mml2jax.js","MathMenu.js","MathZoom.js"],
  TeX: {
    extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
  }
});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<style>
.x {
  background-color: lightgrey;
  border: 10px solid green;
}
.y {
  background-color: lightyellow;
  border: 5px solid black;
}
.z {
  background-color: lightpink;
  border: 5px solid red;
}
.tele {
  background-color: yellow;
  border: 5px solid red;
}
</style>
<a href="http://t.me/CHEGGHAC"><div class=tele><center><h3>CLICK HERE TO GET MORE FREE SOLUTIONS</h3></center></div></a>
<div class="x">
<div class="ugc-base question-body-text">
<div class=""><p><br/>
This function is required to be written in Java 8<br/>
<img alt="You are given a tree consisting of N nodes, numbered from 0 to N-1. Each node contains one of the letters a or b. The tre" aria-describedby="cmv" src="https://media.cheggcdn.com/media/4c4/4c4944ba-6c65-49ec-b49c-e61430bbfc95/phpkCDji4" style="height:766px;width:684px;"/><img alt="Write a function: class Solution { public int solution(String S, int[] A); } that, given string S and array A of Nintegers, r" aria-describedby="cn0" src="https://media.cheggcdn.com/media/f5a/f5a22e2f-707b-4a13-ac8f-63878b7f09d4/phptuTwKR" style="height:796px;"/><img alt="3. Given S = abab and A = [-1, 2, 0, 1), your function should return 2. The longest path is: 2 - 1. It is marked in red on" aria-describedby="cn1" src="https://media.cheggcdn.com/media/5b0/5b03b45c-9bd4-4fb8-9c79-12fcd726c852/php4rHWEh" style="height:576px;width:1166px;"/></p>
</div></div></div></div></div><h1><p><b>
<mark>:: Solution ::</mark>
</b></p></h1><div class="y"><div class="y"><div class="answer-given-body ugc-base">
<p><strong>:: Solution ::</strong></p>
<p>//CPP solution</p>
<p>int maxValidAns;<br/>
void dfs(int curNode, vector&lt;vector&lt;int&gt;&gt; &amp;graph,
string &amp;s, int dp[])<br/>
{<br/>
<br/>
vector&lt;int&gt; possiblePathsFromThisNode; // it will store all
the Valid paths possible from this node to leaf<br/>
dp[curNode] = 1;<br/>
for(auto it : graph[curNode])<br/>
{<br/>
dfs(it, graph, s, dp);<br/>
if(s[curNode] != s[it])<br/>
possiblePathsFromThisNode.push_back(dp[it]);<br/>
}</p>
<p>int sz = possiblePathsFromThisNode.size();<br/>
if(sz-1 &gt;= 0)<br/>
dp[curNode] += possiblePathsFromThisNode[sz-1];<br/>
if(sz-2 &gt;= 0)<br/>
dp[curNode] += possiblePathsFromThisNode[sz-2];</p>
<p>maxValidAns = max(maxValidAns, dp[curNode]);<br/>
}<br/>
int solution(string &amp;s, vector&lt;int&gt; &amp;A)<br/>
{<br/>
int n = s.length();<br/>
int dp[n]; // dp[i] will store the maximum valid path that can be
obtained from the subtree of node i including node i.<br/>
vector&lt;vector&lt;int&gt;&gt; graph(n, vector&lt;int&gt;()); //
creating ajdacency list<br/>
maxValidAns = 0;</p>
<p>for(int i = 1;i &lt; A.size();i++)<br/>
{<br/>
graph[A[i]].push_back(i);<br/>
}</p>
<p>dfs(0, graph, s, dp); // usind depth first search</p>
<p>return maxValidAns;<br/>
}</p>
<p>Dear Chegg student I hope it helpful to you thanks for chegging
please don't do down vote.</p>
</div></div></div></div><div class="z"><h2><p><b>
Likes: 3</p><p>Dislikes:  1
</b></p></h2></div>